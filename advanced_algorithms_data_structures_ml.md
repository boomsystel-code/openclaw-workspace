# 高级算法与数据结构实战

## 第一章：算法设计范式

### 1.1 分治法（Divide and Conquer）

#### 核心思想
将问题分解为多个独立的子问题，递归解决子问题，然后合并结果。

#### 经典应用
- **归并排序（Merge Sort）**
  - 时间复杂度：O(n log n)
  - 空间复杂度：O(n)
  - 稳定排序算法
  - 适用于外部排序

- **快速排序（Quick Sort）**
  - 平均时间复杂度：O(n log n)
  - 最坏情况：O(n²)（可通过随机化避免）
  - 就地排序，空间复杂度O(log n)
  - 不稳定排序

- **二分查找（Binary Search）**
  - 时间复杂度：O(log n)
  - 要求：有序数组
  - 变体：查找第一个/最后一个等于目标值的位置

- **大整数乘法**
  - Karatsuba算法：O(n^1.585)
  - FFT乘法：O(n log n)

- **最近点对问题**
  - 二维平面最近点对
  - 时间复杂度：O(n log n)

#### 实现要点
```
分治法模板：
function solve(problem):
    if problem规模足够小:
        return 直接解决(problem)
    
    分解problem为多个子问题
    solutions = []
    for each subproblem:
        solutions.append(solve(subproblem))
    
    return 合并(solutions)
```

### 1.2 动态规划（Dynamic Programming）

#### 核心概念
将复杂问题分解为重叠子问题，通过存储中间结果避免重复计算。

#### 解决步骤
1. **定义状态**：确定DP数组的含义
2. **状态转移**：建立状态间的关系
3. **初始化**：设置基础情况
4. **计算顺序**：确定遍历方向
5. **结果推导**：得到最终答案

#### 经典问题

**一维DP**
- **斐波那契数列**
  ```
  dp[i] = dp[i-1] + dp[i-2]
  优化：滚动数组，空间O(1)
  ```

- **爬楼梯问题**
  ```
  dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
  考虑步长限制
  ```

- **打家劫舍**
  ```
  dp[i] = max(dp[i-1], dp[i-2] + nums[i])
  线性动态规划
  ```

**二维DP**
- **最长公共子序列（LCS）**
  ```
  dp[i][j] = dp[i-1][j-1] + 1, if s[i] == t[j]
  dp[i][j] = max(dp[i-1][j], dp[i][j-1]), otherwise
  ```

- **背包问题**
  - 0/1背包：每件物品只能选一次
  - 完全背包：物品无限件
  - 多重背包：物品有数量限制
  - 混合背包：多种类型的组合

- **编辑距离**
  ```
  dp[i][j] = min(
      dp[i-1][j] + 1,      // 删除
      dp[i][j-1] + 1,      // 插入
      dp[i-1][j-1] + (s[i]!=t[j])  // 替换
  )
  ```

- **矩阵链乘法**
  - 确定乘法顺序以最小化计算次数
  - 时间复杂度：O(n³)

**状态压缩DP**
- 使用位运算表示状态
- 适用于集合状态较少的情况
- 经典应用：旅行商问题（TSP）的DP解法

**树形DP**
- 在树结构上进行动态规划
- 常见模型：树形背包、树上最大独立集
- 典型问题：树的直径、重心

### 1.3 贪心算法（Greedy Algorithm）

#### 核心思想
在每一步选择当前状态下的最优解，期望最终得到全局最优。

#### 正确性证明
- **贪心选择性质**：全局最优解可以通过局部最优选择得到
- **最优子结构**：问题的最优解包含子问题的最优解

#### 经典问题

**区间调度**
- **选择不相交区间**
  - 按结束时间排序
  - 贪心选择结束最早的区间
  - 时间复杂度：O(n log n)

- **区间覆盖问题**
  - 选择最少数量的区间覆盖目标区间

**哈夫曼编码**
- 构建最优前缀码
- 按频率构建最小堆
- 时间复杂度：O(n log n)

**最小生成树**
- **Prim算法**
  - 从单个顶点开始
  - 每次添加最短边
  - 时间复杂度：O(E log V)

- **Kruskal算法**
  - 按边权重排序
  - 使用并查集检测环
  - 时间复杂度：O(E log E)

**最短路径**
- **Dijkstra算法**
  - 单源最短路径
  - 非负权重边
  - 贪心选择最短距离顶点

### 1.4 回溯法（Backtracking）

#### 核心思想
系统性地搜索问题的解空间，通过尝试所有可能的路径来找到解。

#### 算法框架
```
backtrack(路径, 选择列表):
    if 满足结束条件:
        添加路径到结果集
        return
    
    for 选择 in 选择列表:
        做选择（路径.append(选择)）
        backtrack(路径, 更新后的选择列表)
        撤销选择（路径.pop()）
```

#### 优化技巧
- **剪枝**：提前排除不可能的路径
- **分支限界**：计算上界/下界进行剪枝
- **记忆化**：存储中间状态避免重复计算

#### 经典应用

**排列组合问题**
- 全排列
  ```
  visited数组记录已选元素
  递归生成排列
  ```

- 子集生成
  - 位运算解法
  - 递归解法

**N皇后问题**
- 放置策略：行、列、对角线约束
- 优化：位运算优化冲突检测

**数独求解**
- 候选数填充
- 最少候选数优先（MRV启发式）

**图搜索**
- 深度优先搜索（DFS）
- 广度优先搜索（BFS）
- 双向搜索

---

## 第二章：高级数据结构

### 2.1 平衡树

#### AVL树
- **平衡条件**：左右子树高度差不超过1
- **旋转操作**
  - 单旋转（左旋、右旋）
  - 双旋转（左右旋、右左旋）
- **插入操作**：O(log n)
- **删除操作**：O(log n)
- **查询操作**：O(log n)

#### 红黑树
- **平衡条件**
  - 节点红色或黑色
  - 根节点黑色
  - 叶节点（nil）黑色
  - 红色节点子节点必须黑色
  - 任意节点到叶子的路径黑色节点数相同

- **操作复杂度**
  - 插入：O(log n)
  - 删除：O(log n)
  - 查询：O(log n)

- **应用场景**
  - C++ STL：map、set
  - Java：TreeMap、TreeSet
  - Linux进程调度

#### B树与B+树
- **B树特征**
  - 多路平衡查找树
  - 节点可包含多个键值
  - 所有叶节点在同一层

- **B+树优化**
  - 非叶子节点只存索引
  - 叶子节点存储所有数据
  - 叶子节点链表连接

- **应用场景**
  - 数据库索引
  - 文件系统
  - 磁盘存储优化

### 2.2 堆与优先队列

#### 二叉堆
- **完全二叉树结构**
  - 数组存储
  - 父节点索引：(i-1)/2
  - 左子节点：2*i+1
  - 右子节点：2*i+2

- **操作复杂度**
  - 插入：O(log n)
  - 删除堆顶：O(log n)
  - 查找最值：O(1)

- **堆排序**
  1. 构建最大堆：O(n)
  2. 交换堆顶与末尾：O(log n)
  3. 堆调整：O(log n)
  4. 重复步骤2-3

#### 堆的变体

**d-堆**
- 每个节点有d个子节点
- 适用于d较大时插入更快

**配对堆（Pairing Heap）**
- 可合并堆
- 实际性能优于理论复杂度

**二项堆（Binomial Heap）**
- 可合并堆
- 支持快速合并
- 支持所有优先队列操作

**斐波那契堆（Fibonacci Heap）**
- 理论最优：插入O(1)，删除O(log n)
- 实际应用中合并操作优势明显
- 用于Dijkstra算法的优化

#### 堆的应用

**Top-K问题**
- 找最大的K个数：维护最小堆
- 找最小的K个数：维护最大堆

**中位数维护**
- 双堆结构
- 动态调整平衡

**哈夫曼编码**
- 频率优先处理
- 构建最优编码树

### 2.3 字符串算法

#### 字符串匹配

**KMP算法（Knuth-Morris-Pratt）**
- **核心思想**：利用已匹配信息避免回溯
- **部分匹配表（Next数组）**
  - 计算每个位置的最长前缀后缀匹配
  - 时间复杂度：O(n+m)

**Boyer-Moore算法**
- **跳跃策略**
  - 坏字符规则
  - 好后缀规则
  - 实际应用中比KMP更快

**Rabin-Karp算法**
- **哈希思想**
  - 滚动哈希
  - 快速字符串比较
  - 适合多模式匹配

**Sunday算法**
- **贪心策略**
  - 每次跳跃基于下一个字符
  - 平均性能优于BM

#### 字典树（Trie）

**基本结构**
- 节点包含字符和子节点映射
- 根节点为空
- 每个节点可标记为单词结尾

**时间复杂度**
- 插入：O(m)，m为字符串长度
- 查找：O(m)
- 空间：O(m*n)

**变体与应用**

**压缩字典树（Radix Tree）**
- 压缩单子节点路径
- 节省空间

**后缀树（Suffix Tree）**
- 存储所有后缀
- 支持O(m)字符串查询
- 用于生物信息学

**AC自动机（Aho-Corasick）**
- 多模式字符串匹配
- 构建字典树+失败链接
- 时间复杂度：O(n + m + z)

#### 字符串哈希

**滚动哈希**
- 多项式哈希
- 冲突处理
- 应用：字符串比较、子串查找

**Rabin-Karp哈希**
- 用于模式匹配
- 快速比较
- 冲突检测

### 2.4 图论高级算法

#### 最短路径

**Bellman-Ford算法**
- 支持负权边
- 时间复杂度：O(V*E)
- 检测负权环

**SPFA算法（Shortest Path Faster Algorithm）**
- Bellman-Ford队列优化
- 平均性能更好
- 最坏情况仍为O(V*E)

**Dijkstra算法优化**

**二叉堆实现**
- O(E log V)

**斐波那契堆实现**
- O(E + V log V)
- 理论最优，但实现复杂

**Johnson算法**
- 所有节点对最短路径
- 添加新节点处理负权
- 结合Bellman-Ford和Dijkstra

#### 强连通分量（SCC）

**Tarjan算法**
- **核心思想**：深度优先搜索+栈
- **时间戳和低链接值**
  - dfn[u]：发现时间
  - low[u]：能追溯到的最小时间戳
- **复杂度**：O(V+E)

**Kosaraju算法**
- **两遍DFS**
  - 第一遍：记录完成顺序
  - 反图DFS按逆序处理
- **复杂度**：O(V+E)

**应用**
- 缩点构建DAG
- 条件独立图分析

#### 网络流

**Ford-Fulkerson方法**
- **核心思想**：增广路径
- **残量网络**
  - 正向边容量
  - 反向边流量
- **复杂度**：O(E*max_flow)

**Edmonds-Karp算法**
- **BFS找增广路径**
  - 最短增广路径
  - 复杂度：O(V*E²)

**Dinic算法**
- **层次图+阻塞流**
  - BFS构建层次
  - DFS找阻塞流
  - 复杂度：O(E*sqrt(V))

**应用场景**
- 最大流问题
- 最小割问题
- 二分图匹配
- 任务分配

---

## 第三章：算法竞赛技巧

### 3.1 时间复杂度分析

#### 大O记号
- O(1)：常数时间
- O(log n)：对数时间
- O(n)：线性时间
- O(n log n)：线性对数时间
- O(n²)：平方时间
- O(2ⁿ)：指数时间
- O(n!)：阶乘时间

#### 复杂度估算
- 10⁸次操作 ≈ 1秒
- 常见优化目标
  - 1秒：10⁷-10⁸操作
  - 2秒：2×10⁸操作

#### 空间复杂度
- 内存限制：通常256MB-1GB
- 常用数据结构空间
  - 数组：O(n)
  - 图：O(V+E)
  - DP表：O(n²)或O(n*m)

### 3.2 常见优化技巧

#### 空间优化
- **滚动数组**
  - DP状态复用
  - 从二维降到一维

- **原地修改**
  - 不额外分配空间
  - 输入输出复用

- **稀疏存储**
  - 哈希表代替数组
  - 压缩存储

#### 时间优化
- **预计算**
  - 阶乘、组合数
  - 公共子问题

- **位运算**
  - 快速乘除（移位）
  - 集合操作
  - 状态压缩

- **查表法**
  - 小范围结果缓存
  - 避免重复计算

#### 输入输出优化
- **快速IO**
  - 使用缓冲区
  - scanf/printf（C++）
  - BufferedReader/PrintWriter（Java）

- **文件读取**
  - 离线处理
  - 大文件分块

### 3.3 常见陷阱

#### 整数溢出
- Python自动大整数
- C++/Java注意范围
- long long类型使用

#### 边界条件
- 空输入
- 单元素
- 极端值
- 负数处理

#### 精度问题
- 浮点数比较
- 累积误差
- 整数除法

#### 特殊情况
- 0和空集合
- 重复元素
- 对称情况

---

## 第四章：机器学习算法

### 4.1 监督学习算法

#### 线性模型

**线性回归**
- 假设函数：h(x) = θ₀ + θ₁x₁ + ... + θₙxₙ
- 损失函数：MSE = 1/2m Σ(h(x⁽ⁱ⁾) - y⁽ⁱ⁾)²
- 优化：梯度下降、正规方程

**逻辑回归**
- 假设函数：sigmoid函数
- 损失函数：交叉熵
- 应用：二分类

**正则化**
- L1正则（Lasso）：特征选择
- L2正则（Ridge）：防止过拟合
- 弹性网络：L1+L2

#### 决策树

**ID3算法**
- 信息增益选择特征
- 信息熵计算

**C4.5算法**
- 信息增益比
- 连续特征离散化
- 缺失值处理

**CART算法**
- 基尼系数
- 分类和回归树
- 剪枝处理

#### 集成学习

**Bagging**
- 随机森林
- 并行集成
- 降低方差

**Boosting**
- AdaBoost
- Gradient Boosting
- XGBoost/LightGBM
- 降低偏差

**Stacking**
- 多模型融合
- 元学习器

### 4.2 无监督学习算法

#### 聚类

**K-Means**
- 迭代优化
- K值选择（肘部法则）
- 局部最优问题

**层次聚类**
- 自底向上/自顶向下
- 距离度量选择
- 树状图解读

**DBSCAN**
- 基于密度
- 噪声处理
- 任意形状聚类

**GMM（高斯混合模型）**
- 概率聚类
- EM算法求解
- 软分配

#### 降维

**PCA（主成分分析）**
- 方差最大化
- 特征值分解
- 降维重建

**SVD（奇异值分解）**
- 矩阵分解
- 潜在语义分析
- 推荐系统应用

**t-SNE**
- 高维可视化
- 保留局部结构
- 计算复杂度高

**UMAP**
- 更快的非线性降维
- 更好的全局结构保持

---

## 第五章：算法实战案例

### 5.1 LeetCode高频题解

#### 数组与链表

**两数之和**
- 哈希表优化
- O(n)时间，O(n)空间

**三数之和**
- 排序+双指针
- 去重技巧

**环形链表**
- 快慢指针检测环
- 环入口检测

#### 二叉树

**二叉树遍历**
- 前序、中序、后序
- 层次遍历（BFS）
- Morris遍历（O(1)空间）

**二叉搜索树**
- 验证BST
- 最近公共祖先
- 恢复BST

#### 动态规划

**股票买卖系列**
- 多种状态DP
- 空间优化
- 状态机设计

**子序列问题**
- 最长递增子序列（LIS）
- 最长公共子序列（LCS）
- 编辑距离

#### 图论

**岛屿问题**
- DFS/BFS遍历
- 边界处理
- 计数问题

**拓扑排序**
- Kahn算法
- DFS实现
- 课程表问题

### 5.2 系统设计案例

#### 设计一个URL短链系统

**核心功能**
- 长链转短链
- 短链还原长链
- 统计点击

**关键组件**
- 哈希生成（Base62）
- 存储设计（Redis+MySQL）
- 分布式ID生成

**扩展性**
- 缓存策略
- 限流设计
- 高可用方案

#### 设计一个消息队列

**核心功能**
- 生产者/消费者
- 消息持久化
- 消息确认

**架构设计**
- 主题/队列模型
- 分区设计
- 消费者组

**可靠性保证**
- ACK机制
- 事务消息
- 消息顺序性

---

## 参考资源

### 在线平台
- LeetCode：算法题库
- Codeforces：竞赛平台
- AtCoder：日本竞赛平台
- HackerRank：技能评估

### 书籍推荐
- 《算法导论》（CLRS）
- 《算法（第4版）》- Robert Sedgewick
- 《剑指Offer》
- 《编程之美》

### 视频课程
- MIT 6.006（算法导论）
- MIT 6.046J（算法设计与分析）
- Stanford CS161（算法课）

---

*本知识文件最后更新：2026-02-07*
*包含高级算法、数据结构和机器学习算法*
